## 8088 V1
This is a set of 8088 CPU tests produced by Daniel Balsom and Folkert van Heusden using the [Arduino8088](https://github.com/dbalsom/arduino_8088) interface and the [MartyPC](https://github.com/dbalsom/martypc) emulator.

These tests are produced with an 8088 running in Maximum Mode, with bus signals generated by an attached Intel 8288 Bus Controller.

10,000 tests are provided per opcode, except for string instructions which contain 2,000 tests due to their large size.

All tests assume a full 1MB of RAM is mapped to the processor and writable.

No wait states are incurred during any of the tests. The interrupt and trap flags are not exercised. 

All tests begin after a CPU reset. The simplest way to run each test is to override your emulated CPU's normal reset vector (FFFF:0000) to the CS:IP of the test's initial state, then reset the CPU. Optionally, you can simulate the far jump typically found at the reset vector to jump to the test's CS:IP. The resulting cycle states should align using either method.

The initial state's 'ram' list defines address and byte pairs, including the instruction bytes and subsequent bytes fetched during program execution, and should be written to memory at the start of the test. 

Instruction cycles begin from the cycle in which the QS0 and QS1 status lines indicate an instruction "First Byte" has been fetched - this may be an optional instruction prefix, in which case there will be multiple First Byte statuses. 

Random segment override prefixes have been prepended to a percentage of instructions, even if they may not do anything.

Instruction cycles end at microcode execution flagged with either NXT or RNI, when the first byte of the next instruction is read from the queue. 

All bytes after the initial instruction bytes are set to 0x90 (144) (NOP). Therefore, the queue contents at the end of all tests will contain only NOPs, with a maximum of 3 (since one has been read out).

String instructions may randomly be prepended by a REP or REPE instruction prefix. In this event, CX is masked to 7 bits to produce reasonably sized tests (A string instruction with CX==65535 would be over a million cycles in execution).

Sample test:
```json
{
    "name": "add byte ds:[bx+si+C2h], al",
    "bytes": [0, 64, 194],
    "initial": {
        "regs": {
            "ax": 52773,
            "bx": 22214,
            "cx": 16054,
            "dx": 57938,
            "cs": 60492,
            "ss": 17184,
            "ds": 15619,
            "es": 60510,
            "sp": 56738,
            "bp": 13363,
            "si": 58400,
            "di": 31158,
            "ip": 16937,
            "flags": 62535
        },
        "ram": [
            [264920, 71],
            [984809, 0],
            [984810, 64],
            [984811, 194],
            [984812, 144],
            [984813, 144],
            [984814, 144],
            [984815, 144]
        ],
        "queue": []
    },
    "final": {
        "regs": {
            "ax": 52773,
            "bx": 22214,
            "cx": 16054,
            "dx": 57938,
            "cs": 60492,
            "ss": 17184,
            "ds": 15619,
            "es": 60510,
            "sp": 56738,
            "bp": 13363,
            "si": 58400,
            "di": 31158,
            "ip": 16940,
            "flags": 62470
        },
        "ram": [
            [264920, 108],
            [984809, 0],
            [984810, 64],
            [984811, 194],
            [984812, 144],
            [984813, 144],
            [984814, 144],
            [984815, 144]
        ],
        "queue": [144, 144, 144]
    },
    "cycles": [
        ["-", 984810, "CS", "R--", "---", 0, "CODE", "T2", "F", 0],
        ["-", 984810, "CS", "R--", "---", 64, "PASV", "T3", "-", 0],
        ["-", 984810, "CS", "---", "---", 0, "PASV", "T4", "-", 0],
        ["A", 984811, "--", "---", "---", 0, "CODE", "T1", "-", 0],
        ["-", 984811, "CS", "R--", "---", 0, "CODE", "T2", "S", 64],
        ["-", 984811, "CS", "R--", "---", 194, "PASV", "T3", "-", 0],
        ["-", 984811, "CS", "---", "---", 0, "PASV", "T4", "-", 0],
        ["A", 984812, "--", "---", "---", 0, "CODE", "T1", "-", 0],
        ["-", 984812, "CS", "R--", "---", 0, "CODE", "T2", "-", 0],
        ["-", 984812, "CS", "R--", "---", 144, "PASV", "T3", "-", 0],
        ["-", 984812, "CS", "---", "---", 0, "PASV", "T4", "S", 194],
        ["A", 984813, "--", "---", "---", 0, "CODE", "T1", "-", 0],
        ["-", 984813, "CS", "R--", "---", 0, "CODE", "T2", "-", 0],
        ["-", 984813, "CS", "R--", "---", 144, "PASV", "T3", "-", 0],
        ["-", 984813, "CS", "---", "---", 0, "PASV", "T4", "-", 0],
        ["-", 984813, "--", "---", "---", 0, "PASV", "Ti", "-", 0],
        ["-", 984813, "--", "---", "---", 0, "PASV", "Ti", "-", 0],
        ["A", 264920, "--", "---", "---", 0, "MEMR", "T1", "-", 0],
        ["-", 264920, "DS", "R--", "---", 0, "MEMR", "T2", "-", 0],
        ["-", 264920, "DS", "R--", "---", 71, "PASV", "T3", "-", 0],
        ["-", 264920, "DS", "---", "---", 0, "PASV", "T4", "-", 0],
        ["A", 984814, "--", "---", "---", 0, "CODE", "T1", "-", 0],
        ["-", 984814, "CS", "R--", "---", 0, "CODE", "T2", "-", 0],
        ["-", 984814, "CS", "R--", "---", 144, "PASV", "T3", "-", 0],
        ["-", 984814, "CS", "---", "---", 0, "PASV", "T4", "-", 0],
        ["A", 984815, "--", "---", "---", 0, "CODE", "T1", "-", 0],
        ["-", 984815, "CS", "R--", "---", 0, "CODE", "T2", "-", 0],
        ["-", 984815, "CS", "R--", "---", 144, "PASV", "T3", "-", 0],
        ["-", 984815, "CS", "---", "---", 0, "PASV", "T4", "-", 0],
        ["A", 264920, "--", "---", "---", 0, "MEMW", "T1", "-", 0],
        ["-", 264920, "DS", "-A-", "---", 0, "MEMW", "T2", "-", 0],
        ["-", 264920, "DS", "-AW", "---", 108, "PASV", "T3", "-", 0]
    ]
}
```
The 'name' field is a user-readable disassembly of the instruction.
The 'bytes' list contains the instruction bytes that make up the full instruction. They are provided for convenience only.
The 'initial' and 'final' keys contain the register, memory and queue states before and after instruction execution, respectively.
The 'cycles' list contains sub lists, each corresponding to a single CPU cycle. Each contains several fields. From left to right, the cycle fields are:  

 - ALE line
 - address latch
 - segment status
 - memory status
 - IO status
 - data bus
 - bus status
 - t-state
 - queue operation status
 - queue byte read

The ALE line (Address Latch Enable) is asserted on T1 to instruct the PC's address latches to store the current address. This is necessary since the address and data lines of the 8088 are shared, and a valid address is on the address bus only while ALE is asserted.  Thus the second column represents the value of the address latch, and not the address bus itself (which may not be valid in a given cycle)

The segment status indicates which segment is in use to calculate addresses by the CPU, using segment-offset addressing. This field represents the S3 and S4 status lines of the 8088.

The memory status field represents outputs of the attached i8288 Bus Controller. From left to right, this field will contain RAW or ---.  R represents the MRDC status line, A represents the AMWC status line, and W represents the MWTC status line. These status lines are active-low. A memory read will occur on T3 or the last Tw t-state when MRDC is active. A memory write will occur on T3 or the last Tw t-state when AMWC is active. At this point, the value of the data bus field will be valid and will represent the byte read or written.

The IO status field represents outputs of the attached i8288 Bus Controller. From left to right, this field will contain RAW or ---.  R represents the IORC status line. A represents the AIOWC status line. W represents the IOWC status line. These status lines are active-low. An IO read will occur on T3 or the last Tw t-state when IORC is active. An IO write will occur on T3 or the last Tw t-state when AIOWC is active. At this point, the value of the data bus field will be valid and will represent the byte read or written.

The bus status lines indicate the type of bus m-cycle currently in operation. Either INTA, IOR, IOW, MEMR, MEMW, HALT, CODE, or PASV.  These states represent the S0, S1 and S2 status lines of the 8088.

The t-state is the current t-state of the CPU. Since this state is not exposed by the CPU, it is calculated based on bus activity.

The queue operation status will contain either F, S, E or -. F indicates a "First Byte" of an instruction or instruction prefix has been read.  S indicates a "Subsequent" byte of an instruction has been read - either a modrm, displacement, or operand. E indicates that the instruction queue has been Emptied/Flushed. All queue operation statuses reflect an operation that actually occurred on the previous cycle.  

When the queue operation status is not '-', then the value of the queue byte read field is valid and represents the byte read from the queue. This field represents the QS0 and QS1 status lines of the 8088. 

For more information on the 8088 and 8288 status lines, see their respective white papers.

If you are not interested in writing a cycle-accurate emulator, you may only be interested in the final register and ram state.

Note that these tests include many undocumented or invalid opcodes. The 8088 has no concept of an invalid instruction, and will perform some task for any provided sequence of instruction bytes. Additionally, flags may be changed by documented instructions in ways that are officially undefined.

### Per-Instruction Notes

8F: The behavior of 8F with reg != 0 is undefined. If you can figure out the rules governing its behavior, please let us know.
9B: WAIT is not included in this test set.
8D/C4/C5: 'r, r' forms of LEA, LES, LDS are undefined. These forms are not included in this test set as their behavior requires access to the previously calculated Effective Address which is not available.
F1: This is listed as an undefined instruction by many sources, but I believe it is an unused prefix.
F4: HALT is not included in this test set.

### 8088.json

If you are not interested in emulating the undefined behavior of the 8088, you can use the included 8088.json file which lists which instructions are undocumented or undefined and provides values that can be used to mask undefined flags.

In 8088.json, opcodes are listed as object keys, each a key being the opcode as a two character hex string. Each opcode entry has a 'status' field which may be 'normal', 'prefix', 'alias', 'undocumented', 'undefined', or 'fpu'.

An opcode marked 'prefix' is an instruction prefix.
An opcode marked 'alias' is simply an alias for another instruction. These exist because the mask that determines which microcode maps to which opcode is not always perfectly specific. 
An opcode marked 'undocumented' has well-defined and potentially useful behavior, such as SETMO and SETMOC. 
An opcode marked 'undefined' likely has unusual or unpredictable behavior.
An opcode marked 'fpu' is an FPU instruction.

If present, the 'flags' field indicates which flags are undefined after the instruction has executed. A flag is either a letter from the pattern `odiszapc` indicating it is undefined, or a period, indicating it is not undefined. The 'flags-mask' field is a 16 bit value that can be applied with an AND to the flags register after instruction execution to clear any flags left undefined.

An opcode may have a 'reg' field which will be an object of opcode extensions/register specifiers represented by single digit string keys - this is the 'reg' field of the modrm byte.  Certain opcodes may be defined or undefined depending on their register specifier or opcode extension. Therefore, each entry within this 'reg' object will have the same fields as a top-level opcode object. 



